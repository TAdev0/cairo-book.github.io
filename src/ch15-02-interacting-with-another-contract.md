# Interacting with Another Contract

We explained in the previous section that contract interactions were made using the _dispatcher_ pattern. This pattern allows us to call functions on another contract by using a struct that wraps the contract address and implements the dispatcher trait generated by the compiler from the contract class ABI. This leverages Cairo's trait system to provide a clean and type-safe way to interact with other contracts.

This dispatcher is automatically generated by the compiler from the definition of a [contract interface][interfaces]. Actually, when contract interface is defined, multiple dispatchers are automatically generated and exposed by the compiler: the _Contract Dispatchers_ and the _Library Dispatchers_. For example, for a standard `ERC20` contract, defining an `ERC20` interface would expose:

- The _Contract Dispatchers_ `IERC20Dispatcher` and `IERC20SafeDispatcher`.
- The _Library Dispatchers_ `IERC20LibraryDispatcher` and `IERC20SafeLibraryDispatcher`.

Library dispatchers follow the same pattern as contract dispatchers, but are used to call functions on library contracts. Instead of wrapping a contract address, they wrap a class hash.
Library dispatchers will be discussed in the next chapter, ["Running code from an external class"][library dispatcher].

The "Safe" dispatchers are used to call functions on other contracts without unwrapping the `SyscallResult` returned by the contract call, allowing the caller to handle eventual errors during the execution of the call

> Note: As of Starknet 0.13.2, error handling in contract calls is not yet available. This means that if a contract call fails, the entire transaction will fail. This will change in the future, allowing safe dispatchers to be used on Starknet.

Under the hood, these dispatchers use the low-level [`contract_call_syscall`][syscalls], which allows us to call functions on other contracts by passing the contract address, the function selector, and the function arguments. The dispatcher abstracts away the complexity of this syscall, providing a clean and type-safe way to interact with other contracts.

In this chapter, we are going to focus on cross-contract interaction using contract dispatchers. To effectively break down the concepts involved, we will use the `ERC20` interface as an illustration.

[interfaces]: ./ch13-02-anatomy-of-a-simple-contract.md#the-interface-the-contracts-blueprint
[syscalls]: ./appendix-08-system-calls.md
[library dispatcher]: ./ch15-03-borrowing-code-from-another-contract-class.md

## The Dispatcher Pattern

We mentioned that the compiler would automatically generate the dispatcher struct and the dispatcher trait for a given interface. Listing {{#ref expanded-ierc20dispatcher}} shows an example of the generated items for an `IERC20` interface that exposes a `name` view function and a `transfer` external function:

```rust,noplayground
{{#include ../listings/ch15-starknet-cross-contract-interactions/listing_02_expanded_ierc20_dispatcher/src/lib.cairo}}
```

{{#label expanded-ierc20dispatcher}}
<span class="caption">Listing {{#ref expanded-ierc20dispatcher}}: A simplified example of the `IERC20Dispatcher` and its associated trait and impl</span>

As you can see, the contract dispatcher is a simple struct that wraps a contract address and implements the `IERC20DispatcherTrait` generated by the compiler. For each function, the implementation of the trait will contain the following elements:

- A serialization of the function arguments into a `felt252` array, `__calldata__`.
- A low-level contract call using `contract_call_syscall` with the contract address, the function selector, and the `__calldata__` array.
- A deserialization of the returned value into the expected return type.

## Calling Contracts Using the Contract Dispatcher

To illustrate how to use the contract dispatcher, we will create a simple contract that wraps an ERC20 contract, allowing us to call the `name` and `transfer_from` functions on the ERC20 contract. The definition of the contract is shown in Listing {{#ref contract-dispatcher}}:

```rust,noplayground
{{#rustdoc_include ../listings/ch15-starknet-cross-contract-interactions/listing_03_contract_dispatcher/src/lib.cairo:here}}
```

{{#label contract-dispatcher}}
<span class="caption">Listing {{#ref contract-dispatcher}}: A sample contract which uses the dispatcher pattern to call another contract</span>

In this contract, we import the `IERC20Dispatcher` struct and the `IERC20DispatcherTrait` trait. We then wrap the address of the ERC20 contract in an instance of the `IERC20Dispatcher` struct. This allows us to call the `name` and `transfer` functions on the ERC20 contract.

Calling `transfer_token` external function will modify the state of the contract deployed at `contract_address`.

## Calling Contracts using Low-Level Calls

Another way to call other contracts is to directly use the `call_contract_syscall`. While less convenient than using the dispatcher pattern, this syscall provides more control over the serialization and deserialization process and allows for more customized error handling.

Listing {{#ref syscalls}} shows an example demonstrating how to call the `transfer_from` function of an `ERC20` contract with a low-level `call_contract_sycall` syscall:

```rust,noplayground
{{#include ../listings/ch15-starknet-cross-contract-interactions/listing_06_syscalls/src/lib.cairo}}
```

{{#label syscalls}}
<span class="caption">Listing {{#ref syscalls}}: A sample contract using `call_contract_sycall` syscall</span>

To use this syscall, we passed in the contract address, the selector of the function we want to call and the call arguments.
The call arguments must be provided as an array of arguments, serialized to a `Span<felt252>`. To serialize the arguments, we can simply use the `Serde` trait, provided that the types being serialized implement this trait. The call returns an array of serialized values, which we'll need to deserialize ourselves!
